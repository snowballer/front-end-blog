# Router

> 随着前端应用的业务复杂度提升、用户体验的要求提高，单页应用（Single Page Application）成为前端应用的主流形式。大型单页应用最显著特点之一就是采用前端路由系统，通过改变URL，在不重新请求页面的情况下，更新页面视图。绝大数前端框架都会配置独立开发或推荐使用的路由库。

## 前端路由的实现方式

1.hashHistory:

通过hashchange事件来监听window.location.hash的变化来实现路由功能。

优点：

由于hashchange为旧标准，浏览器支持度高，兼容IE。

hash模式仅改变hash部分的内容，而hash部分不会包含在HTTP请求中的：
```javascript

www.demo.com/#/user/id   // 如重新请求只会发送www.demo.com
```
在hash模式下遇到根据URL请求页面的情况不会出现问题。

缺点：路径匹配时会多出/#/部分

2.browserHistory:

通过popState事件来监听window.history中的pushState()和replaceState()方法来实现路由功能。

缺点：

由于popState为HTML5新标准，旧浏览器不支持，IE兼容性差。

history模式则会将URL修改得就和正常请求后端的URL一样，会请求如下地址：
```javascript

www.demo.com/user/id   // 如重新请求会发送www.demo.com/user/id
```
在此情况下重新向后端发送请求，如后端没有配置对应/user/id的路由处理，则会返回404错误。官方推荐的做法：如果URL匹配不到任何静态资源，则应该返回同一个 index.html 页面，实际开发中也可以配置一个404页面。

优点：

 - 可以支持hash，可以很方便地操作浏览器历史记录，url更优雅

 - pushState设置的新URL可以是与当前URL同源的任意URL；而hash只可修改#后面的部分，故只可设置与当前同文档的URL

 - pushState设置的新URL可以与当前URL一模一样，这样也会把记录添加到栈中；而hash设置的新值必须与原来不一样才会触发记录添加到栈中

## API说明

- HashChangeEvent：

  当URL中的片段标识符发生改变时触发（URL中紧跟'#'号的部分，包括'#'号）

- PopStateEvent：

  当活动历史记录条目更改时，将触发popstate事件。需要注意的是调用history.pushState()或history.replaceState()不会触发popstate事件。只有在做出浏览器动作时，才会触发该事件，如用户点击浏览器的回退按钮（或者在Javascript代码中调用history.back()）

- history.state

  当前URL下对应的状态信息。如果当前URL不是通过pushState或者replaceState产生的，那么history.state是null。

- history.pushState(state, title, url)

  将当前URL和history.state加入到history中，并用新的state和URL替换当前。不会造成页面刷新。

  state：与要跳转到的URL对应的状态信息。

  title：所添加记录的标题，各浏览器支持度不同，可忽略。

  url：要跳转到的URL地址，不能跨域。

  ```javascript

  var stateObj = { foo: "bar" };
  history.pushState(stateObj, "page 2", "bar.html");
  ```

- history.replaceState(state, title, url)

  用新的state和URL替换当前。不会造成页面刷新。

  state：与要跳转到的URL对应的状态信息。

  title：所添加记录的标题，各浏览器支持度不同，可忽略。

  url：要跳转到的URL地址，不能跨域。

  ```javascript

  var stateObj = { foo: "bar" };
  history.replaceState(stateObj, "page 3", "bar2.html");
  ```

## 前端路由实现流程

1.配置路由模式：

  根据用户传入mode来采用hashHistory还是browserHistory，并对不支持browserHistory的浏览器强制使用hashHistory

2.配置路由参数：

  将一系列的路由参数添加到routes数组中，以进行路径匹配
  ```javascript

  var route1 = {
      pathname: 'pathname1', // 路由路径名
      name: 'name1', // 路由名称
      hander: function () {} // 路由处理函数
  }

  var route2 = {
      pathname: 'pathname2', // 路由路径名
      name: 'name2', // 路由名称
      hander: function () {} // 路由处理函数
  }

  var routes = [route1,route2]
  ```

3.监听路由变化：

当用户通过点击、操作浏览器历史及直接访问url时，获取当前url对应的pathname来匹配路由

```javascript

function () {
    // 绑定监听事件            
    if(this.mode === 'history'){
        this.addEventListener(window, 'popstate', function () {
            var path = location.pathname;
            routes.match(path);
        });
    } else {
        this.addEventListener(window, 'hashchange', function () {
            // location.hash默认返回的是带#号的hash，需要去掉#号
            var path = location.hash.replace(/^#/,'');
            routes.match(path);
        });
    }
}

```

4.触发路由处理函数：

  根据当前url匹配对应的路由处理函数，进而渲染页面

```javascript

function(){
  if (routes.match(path)) {
    //获取该path对应的route下的handle,并进行调用
    handle()
  }
}

```
